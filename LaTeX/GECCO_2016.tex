\documentclass{sig-alternate}

\usepackage{times}
\usepackage{url}
\usepackage{todonotes}
\sloppy

\setlength{\parindent}{0.5cm} 

\newcommand{\citep}[1]{\cite{#1}}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\doi{10.475/123_4}

% ISBN
\isbn{123-4567-24-567/08/06}

\acmPrice{\$15.00}

% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\begin{document}

\conferenceinfo{GECCO'16,} {July 20-24, 2016, Denver, Colorado, USA.}
\CopyrightYear{2016}
\crdata{TBA}
\clubpenalty=10000
\widowpenalty = 10000

\title{Visualizing genetic programming ancestries using graph databases}

%\numberofauthors{4}
%\author{
%\alignauthor
%Nicholas Freitag McPhee\\
%	\affaddr{Div. of Science and Math}\\
%	\affaddr{Univ. of Minnesota, Morris}\\
%	\affaddr{Morris, MN USA-56267}\\
%	\email{mcphee@morris.umn.edu}
%\alignauthor
%Maggie M. Casale\\
%	\affaddr{Div. of Science and Math}\\
%	\affaddr{Univ. of Minnesota, Morris}\\
%	\affaddr{Morris, MN USA-56267}\\
%	\email{casal033@morris.umn.edu}
%\and
%\alignauthor
%Thomas Helmuth\\
%	\affaddr{Computer Science Dep't}\\
%	\affaddr{Washington and Lee Univ.}\\
%	\affaddr{Lexington, VA USA-24450}\\
%	\email{helmutht@wlu.edu}
%\alignauthor
%Lee Spector\\
%	\affaddr{Cognitive Science}\\
%	\affaddr{Hampshire College}\\
%	\affaddr{Amherst, MA USA-01002}\\
%	\email{lspector@hampshire.edu}
%}

\maketitle

\begin{abstract}

\todo[inline]{We are submitting this in the hopes of it being a \textbf{poster} and not a paper. There's just not a separate mechanism for submitting specifically for posters.

~

We've tried to keep this close to 2 pages, which is the limit we'll have if this is in fact accepted as a poster. As a result, this submission only includes two of our smaller ancestry graphs. Our intent is for the the poster to include at least one much larger graph, showing the complete ancestry of the winners for a run with nearly 1,000 generations, along with several other comparisons, such as the dynamics of lexicase vs. tournament selection.

~

The graphs we have included are PDF vector graphics and support very high levels of zooming if your PDF viewer allows it.

~

Thanks -- The authors}

Previous work has demonstrated the utility of graph databases as a tool for collecting and analyzing ancestry in evolutionary computation runs. That work focused on sections of individual runs, whereas this poster illustrates the application of these ideas on the entirety of large runs (up to one million individuals) and combinations of multiple runs.

Here we use these tools to generate graphs showing \emph{all} the ancestors of successful individuals from a variety of stack-based genetic programming runs on software synthesis problems. These graphs highlight important moments in the evolutionary process. They also allow us to compare the dynamics when using different evolutionary tools, such as different selection mechanisms or representations, as well as comparing the dynamics for successful and unsuccessful runs.

\end{abstract}

\begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10003120.10003145.10003146.10010892</concept_id>
	<concept_desc>Human-centered computing~Graph drawings</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	<concept>
	<concept_id>10003120.10003145.10003147.10010364</concept_id>

	<concept_desc>Human-centered computing~Scientific visualization</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	<concept>
	<concept_id>10010147.10010178.10010205.10010206</concept_id>
	<concept_desc>Computing methodologies~Heuristic function construction</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	<concept>
	<concept_id>10010147.10010257.10010293.10011809.10011813</concept_id>
	<concept_desc>Computing methodologies~Genetic programming</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Human-centered computing~Graph drawings}
\ccsdesc[500]{Human-centered computing~Scientific visualization}
\ccsdesc[300]{Computing methodologies~Heuristic function construction}
\ccsdesc[300]{Computing methodologies~Genetic programming}

\printccsdesc

\keywords{visualization; genetic programming; graph database; ancestry}

\section{Introduction}
\label{sec:introduction}

Reporting results of genetic programming (GP) and evolutionary computation is frequently limited to aggregate statistics such as mean best fitness or percentage of successful runs. Unfortunately this fails to convey the complex dynamics of such evolutionary systems and obscures or omits potentially valuable information about \emph{why} the runs behaved as they did. Previous work~\cite{McPhee:2015:GPTP} has demonstrated the utility of graph databases as tools for collecting and analyzing ancestry in GP runs, but was focused on sections of individual runs.

In this poster we illustrate the use of these tools as a means of exploring entire ancestry trees. We use the Titan graph database\footnote{\url{http://thinkaurelius.github.io/titan/}} along with the Gremlin shell and the Tinkerpop query tools\footnote{\url{https://tinkerpop.incubator.apache.org/}} to store the parent-child relationships from genetic programming runs, and to extract the ancestry trees of specified individuals. We then visualize these subgraphs using the Graphviz \texttt{dot} graph layout tool\footnote{\url{http://www.graphviz.org/}}.

\section{Example: Success vs. failure}
\label{sec:examples}

Here we illustrate these ideas by extracting and plotting the ancestors of final generation individuals in both a successful (Figure~\ref{fig:success}) and an unsuccessful run (Figure~\ref{fig:fail}) of the replace-space-with-newline software synthesis problem~\cite{Helmuth:2015:GECCO,Helmuth:2015:dissertation} using lexicase selection~\cite{Helmuth:2014:ieeeTEC}. The successful run shows all the ancestors of that run's winners (i.e., individuals with total error 0, discovered at generation 129). The unsuccessful run shows the ancestors of all individuals from generation 300, when the run was terminated.

\begin{figure}[t]
	\centering
	\includegraphics[height=0.5 \textheight]{../Figures/output_success.pdf}
	\caption{Ancestry tree for the one individual with total error 0 in a successful run of the replace-space-with-newline problem using lexicase selection.}
	\label{fig:success}
\end{figure}

\begin{figure}[p]
	\centering
	\includegraphics[height=0.91\textheight]{../Figures/output_fail.pdf}
	\caption{Ancestry tree for all of the individuals in the final generation for an unsuccessful run of the replace-space-with-newline problem using lexicase selection.}
	\label{fig:fail}
\end{figure}

In these figures generations run from the initial random population at the top to the final generation at the bottom, one generation per row. Both of these runs used a population size of 1,000, but far fewer individuals are included in the graphs because only a (sometimes small) subset of the individuals in any given generation go on to be ancestors of individuals in subsequent generations. Each individual is represented as a rectangle whose width is proportional to the number of parent selections that individual received, and whose height is proportional to the number of its offspring that are included in the ancestry graph. 
% The ratio of width to number of selections is $\sfrac{1}{5}$ the ratio of height to number of ancestral children to keep the graph from getting too wide.
The color of an individual is determined by its total error; 0 total error is bright green, moving through blues to bright red, which represents total error of 10,000 or greater. A directed edge in the graph indicates a parent-child relation, with the edge going from the parent down to the child. A child with only a single incoming edge is the result of a mutation operator and children with two incoming edges are the result of a recombination; see~\cite{Helmuth:2015:dissertation,Spector:2013:GPTP} for additional details.

Both Figures~\ref{fig:success} and~\ref{fig:fail} illustrate a common pattern in the early generations where there a substantial number of highly selected individuals (i.e., very wide rectangles). This is presumably because most individuals in the early generations perform poorly, as evidenced by the prevalence of red and pink, leaving a handful of slightly-less-bad individuals to receive the bulk of the selections. After several generations, however, the population gains competence (as evidenced by more purple and dark blue) and there are fewer instances where a single individual receives a very high proportion of the selection events, as evidenced by the large number of small rectangles.

After that initial phase, the behavior in the unsuccessful run (Figure~\ref{fig:fail}) becomes static, with the width of the graph (essentially the number of parents in each generation) remaining roughly constant, with no highly selected (i.e., wide) individuals. The colors also indicate that the total error is not improving substantially over time, remaining mostly between pink and purple. The best total error in fact remains at 234 from generation 16 to 270, although there is a gradual improvement in the last 30 generations with the best error at the end of the run being 215.

In the successful run (Figure~\ref{fig:success}), however, there are clear changes in the dynamics over time. By generation 14, the best individual is able to correctly solve 124 of the 200 test cases for replace-space-with-newline. Then starting around generation 59 there is a ``narrowing'' of the graph, with several highly selected (i.e., wide) individuals dominating the ancestry for the next ten generations. This narrowing represents an important ``discovery'' which leads to individuals that have zero error on an additional 9\% (18) of the test cases. The graph widens out again after that until the rapid convergence on the solution in the final generations. The graph also highlights three highly selected individuals in generation 87 where for the first time the best individual has zero error on an additional 18 test cases.

\section{Filtering}
\label{sec:filtering}

While the large graphs of full runs can provide an excellent ``big picture'' 
view of the run dynamics, there is \emph{so} much information that it can be
difficult to isolate specific features. We can, however, extract and visualize
subgraphs that focus on specific areas or events in the runs.

One simple example of this sort of filtering that we've already introduced is
looking only at individuals that are in fact ancestors of individuals in the
final generation. Most individuals in evolutionary systems aren't ultimately
ancestors of individuals in the final population; they're evolutionary ``dead ends'',
either because they have no children, or their descendants eventually fail to have
children. All the graphs provided so far have used this filtering to substantially
cut down on the number of visualized nodes. This typically reduces the number of nodes in a
generation (row of the graph) from the original 1,000 to 300 or less, and sometimes down
to a few dozen.

\begin{figure*}[tb]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{../Figures/lex_run0_RBM_color_filtered_and_full_30000.pdf}
	\end{center}
	\caption{Unfiltered (left) and filtered (right) versions of a successful lexicase run, both with the same color map.}
	\label{fig:lexRun0FilteredAndFull}
\end{figure*}

\section{Future work}
\label{sec:futurework}

Dynamic views would be nice.

\bibliographystyle{abbrv}
\bibliography{GECCO_2016}

\end{document}